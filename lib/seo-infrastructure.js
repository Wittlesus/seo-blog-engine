'use strict';

const fs = require('fs');
const path = require('path');

/**
 * SEO Infrastructure Module
 * Advanced SEO tools for the blog engine including:
 * - Sitemap generation
 * - Robots.txt generation
 * - Canonical URLs
 * - Open Graph / Twitter Cards
 * - JSON-LD structured data
 * - Image alt text suggestions
 * - 301 redirect management
 */

/**
 * Parse frontmatter from a markdown file
 */
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return null;

  const frontmatterText = match[1];
  const metadata = {};

  frontmatterText.split('\n').forEach((line) => {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) return;

    const key = line.substring(0, colonIndex).trim();
    let value = line.substring(colonIndex + 1).trim();

    // Remove quotes
    value = value.replace(/^["']|["']$/g, '');

    // Parse arrays
    if (value.startsWith('[')) {
      const arrayMatch = value.match(/\[(.*?)\]/);
      if (arrayMatch) {
        metadata[key] = arrayMatch[1]
          .split(',')
          .map((item) => item.trim().replace(/^["']|["']$/g, ''))
          .filter(Boolean);
      }
    } else {
      metadata[key] = value;
    }
  });

  return metadata;
}

/**
 * Extract H1 tag from markdown content
 */
function extractH1(content) {
  const match = content.match(/^#\s+(.+)$/m);
  return match ? match[1] : null;
}

/**
 * Extract all images from markdown content
 */
function extractImages(content) {
  const imageRegex = /!\[(.*?)\]\((.*?)\)/g;
  const images = [];
  let match;

  while ((match = imageRegex.exec(content)) !== null) {
    images.push({
      alt: match[1],
      src: match[2],
    });
  }

  return images;
}

/**
 * Generate sitemap.xml from a directory of markdown posts
 *
 * @param {string} postsDir - Directory containing markdown posts
 * @param {string} baseUrl - Base URL of the site (e.g., "https://example.com")
 * @param {Object} options - Optional settings
 * @returns {string} XML sitemap content
 */
function generateSitemap(postsDir, baseUrl, options = {}) {
  const defaults = {
    defaultChangeFreq: 'monthly',
    defaultPriority: '0.8',
    homepagePriority: '1.0',
    blogIndexPriority: '0.9',
  };

  const opts = { ...defaults, ...options };

  // Remove trailing slash from baseUrl
  baseUrl = baseUrl.replace(/\/$/, '');

  const files = fs.readdirSync(postsDir).filter((f) => f.endsWith('.md'));

  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';

  // Homepage
  xml += '  <url>\n';
  xml += `    <loc>${baseUrl}/</loc>\n`;
  xml += `    <changefreq>weekly</changefreq>\n`;
  xml += `    <priority>${opts.homepagePriority}</priority>\n`;
  xml += '  </url>\n';

  // Blog index
  xml += '  <url>\n';
  xml += `    <loc>${baseUrl}/blog</loc>\n`;
  xml += `    <changefreq>weekly</changefreq>\n`;
  xml += `    <priority>${opts.blogIndexPriority}</priority>\n`;
  xml += '  </url>\n';

  // Individual posts
  files.forEach((file) => {
    const filepath = path.join(postsDir, file);
    const content = fs.readFileSync(filepath, 'utf-8');
    const metadata = parseFrontmatter(content);

    if (!metadata || !metadata.slug) return;

    const slug = metadata.slug.replace(/^\//, ''); // Remove leading slash if present
    const date = metadata.date || new Date().toISOString().split('T')[0];

    // Determine change frequency based on post age
    const postDate = new Date(date);
    const now = new Date();
    const daysSincePublish = Math.floor((now - postDate) / (1000 * 60 * 60 * 24));

    let changefreq = opts.defaultChangeFreq;
    if (daysSincePublish < 7) {
      changefreq = 'daily';
    } else if (daysSincePublish < 30) {
      changefreq = 'weekly';
    }

    // Determine priority (newer posts get higher priority)
    let priority = parseFloat(opts.defaultPriority);
    if (daysSincePublish < 30) {
      priority = Math.min(0.9, priority + 0.1);
    }

    xml += '  <url>\n';
    xml += `    <loc>${baseUrl}/${slug}</loc>\n`;
    xml += `    <lastmod>${date}</lastmod>\n`;
    xml += `    <changefreq>${changefreq}</changefreq>\n`;
    xml += `    <priority>${priority.toFixed(1)}</priority>\n`;
    xml += '  </url>\n';
  });

  xml += '</urlset>\n';

  return xml;
}

/**
 * Generate robots.txt
 *
 * @param {string} sitemapUrl - Full URL to sitemap.xml
 * @param {Object} options - Optional settings
 * @returns {string} robots.txt content
 */
function generateRobotsTxt(sitemapUrl, options = {}) {
  const defaults = {
    allowAll: true,
    disallowPaths: ['/admin', '/api', '/_next', '/private'],
    crawlDelay: null,
  };

  const opts = { ...defaults, ...options };

  let txt = '# robots.txt for SEO Blog Engine\n';
  txt += '# Generated by seo-infrastructure.js\n\n';

  txt += 'User-agent: *\n';

  if (opts.allowAll) {
    txt += 'Allow: /\n';
  }

  if (opts.disallowPaths.length > 0) {
    opts.disallowPaths.forEach((p) => {
      txt += `Disallow: ${p}\n`;
    });
  }

  if (opts.crawlDelay) {
    txt += `Crawl-delay: ${opts.crawlDelay}\n`;
  }

  txt += '\n';
  txt += `Sitemap: ${sitemapUrl}\n`;

  return txt;
}

/**
 * Generate canonical URL meta tag
 */
function generateCanonical(baseUrl, slug) {
  const url = `${baseUrl.replace(/\/$/, '')}/${slug.replace(/^\//, '')}`;
  return `<link rel="canonical" href="${url}" />`;
}

/**
 * Generate Open Graph meta tags for a blog post
 */
function generateOpenGraph(metadata, baseUrl) {
  const slug = metadata.slug.replace(/^\//, '');
  const url = `${baseUrl.replace(/\/$/, '')}/${slug}`;
  const title = metadata.title || 'Blog Post';
  const description = metadata.description || '';
  const image = metadata.featured_image || `${baseUrl}/og-default.jpg`;
  const type = 'article';

  let og = '';
  og += `<meta property="og:title" content="${title}" />\n`;
  og += `<meta property="og:description" content="${description}" />\n`;
  og += `<meta property="og:type" content="${type}" />\n`;
  og += `<meta property="og:url" content="${url}" />\n`;
  og += `<meta property="og:image" content="${image}" />\n`;

  if (metadata.date) {
    og += `<meta property="article:published_time" content="${metadata.date}" />\n`;
  }

  if (metadata.author && metadata.author !== '[AUTHOR_NAME]') {
    og += `<meta property="article:author" content="${metadata.author}" />\n`;
  }

  if (metadata.tags && Array.isArray(metadata.tags)) {
    metadata.tags.forEach((tag) => {
      og += `<meta property="article:tag" content="${tag}" />\n`;
    });
  }

  return og;
}

/**
 * Generate Twitter Card meta tags
 */
function generateTwitterCard(metadata, baseUrl, twitterHandle = null) {
  const slug = metadata.slug.replace(/^\//, '');
  const url = `${baseUrl.replace(/\/$/, '')}/${slug}`;
  const title = metadata.title || 'Blog Post';
  const description = metadata.description || '';
  const image = metadata.featured_image || `${baseUrl}/twitter-card-default.jpg`;

  let twitter = '';
  twitter += `<meta name="twitter:card" content="summary_large_image" />\n`;
  twitter += `<meta name="twitter:title" content="${title}" />\n`;
  twitter += `<meta name="twitter:description" content="${description}" />\n`;
  twitter += `<meta name="twitter:image" content="${image}" />\n`;

  if (twitterHandle) {
    twitter += `<meta name="twitter:site" content="@${twitterHandle.replace('@', '')}" />\n`;
    twitter += `<meta name="twitter:creator" content="@${twitterHandle.replace('@', '')}" />\n`;
  }

  return twitter;
}

/**
 * Generate JSON-LD structured data for a blog post
 */
function generateJSONLD(metadata, baseUrl, options = {}) {
  const defaults = {
    authorName: 'Site Author',
    authorUrl: baseUrl,
    publisherName: 'Blog Name',
    publisherLogo: `${baseUrl}/logo.png`,
    organizationName: 'Your Organization',
  };

  const opts = { ...defaults, ...options };

  const slug = metadata.slug.replace(/^\//, '');
  const url = `${baseUrl.replace(/\/$/, '')}/${slug}`;

  // Article schema
  const article = {
    '@context': 'https://schema.org',
    '@type': 'Article',
    headline: metadata.title || 'Blog Post',
    description: metadata.description || '',
    image: metadata.featured_image || `${baseUrl}/default-image.jpg`,
    datePublished: metadata.date || new Date().toISOString().split('T')[0],
    dateModified: metadata.date || new Date().toISOString().split('T')[0],
    author: {
      '@type': 'Person',
      name: metadata.author && metadata.author !== '[AUTHOR_NAME]' ? metadata.author : opts.authorName,
      url: opts.authorUrl,
    },
    publisher: {
      '@type': 'Organization',
      name: opts.publisherName,
      logo: {
        '@type': 'ImageObject',
        url: opts.publisherLogo,
      },
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': url,
    },
  };

  if (metadata.tags && Array.isArray(metadata.tags)) {
    article.keywords = metadata.tags.join(', ');
  }

  // BreadcrumbList schema
  const breadcrumb = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      {
        '@type': 'ListItem',
        position: 1,
        name: 'Home',
        item: baseUrl,
      },
      {
        '@type': 'ListItem',
        position: 2,
        name: 'Blog',
        item: `${baseUrl}/blog`,
      },
      {
        '@type': 'ListItem',
        position: 3,
        name: metadata.title || 'Post',
        item: url,
      },
    ],
  };

  // Organization schema
  const organization = {
    '@context': 'https://schema.org',
    '@type': 'Organization',
    name: opts.organizationName,
    url: baseUrl,
    logo: {
      '@type': 'ImageObject',
      url: opts.publisherLogo,
    },
  };

  // WebSite schema
  const website = {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: opts.publisherName,
    url: baseUrl,
    potentialAction: {
      '@type': 'SearchAction',
      target: `${baseUrl}/search?q={search_term_string}`,
      'query-input': 'required name=search_term_string',
    },
  };

  return {
    article,
    breadcrumb,
    organization,
    website,
  };
}

/**
 * Generate image alt text suggestions based on filename and context
 */
function suggestAltText(imageSrc, context = {}) {
  const filename = path.basename(imageSrc, path.extname(imageSrc));

  // Remove common patterns
  const cleaned = filename
    .replace(/-hero$/, '')
    .replace(/-section-\d+$/, '')
    .replace(/^option-\d+$/, 'product screenshot')
    .replace(/-/g, ' ')
    .replace(/_/g, ' ');

  const suggestions = [];

  // Basic suggestion
  suggestions.push(cleaned);

  // With context
  if (context.topic) {
    suggestions.push(`${cleaned} for ${context.topic}`);
    suggestions.push(`${context.topic} - ${cleaned}`);
  }

  // With keyword
  if (context.keyword) {
    suggestions.push(`${cleaned} showing ${context.keyword}`);
    suggestions.push(`${context.keyword} ${cleaned}`);
  }

  // Descriptive variations
  if (imageSrc.includes('hero')) {
    suggestions.push(`Complete guide to ${context.topic || cleaned}`);
    suggestions.push(`${context.topic || cleaned} tutorial hero image`);
  }

  if (imageSrc.includes('comparison') || imageSrc.includes('table')) {
    suggestions.push(`${context.topic || cleaned} comparison table`);
    suggestions.push(`Side by side comparison of ${context.topic || cleaned}`);
  }

  if (imageSrc.includes('screenshot')) {
    suggestions.push(`Screenshot of ${context.topic || cleaned}`);
    suggestions.push(`${context.topic || cleaned} interface screenshot`);
  }

  return suggestions;
}

/**
 * Load redirect configuration from JSON file
 */
function loadRedirects(configPath) {
  if (!fs.existsSync(configPath)) {
    return [];
  }

  const content = fs.readFileSync(configPath, 'utf-8');
  return JSON.parse(content);
}

/**
 * Save redirect configuration to JSON file
 */
function saveRedirects(configPath, redirects) {
  fs.writeFileSync(configPath, JSON.stringify(redirects, null, 2), 'utf-8');
}

/**
 * Add a 301 redirect rule
 */
function addRedirect(configPath, from, to, permanent = true) {
  const redirects = loadRedirects(configPath);

  // Check if redirect already exists
  const existing = redirects.find((r) => r.from === from);
  if (existing) {
    existing.to = to;
    existing.permanent = permanent;
    existing.updated = new Date().toISOString();
  } else {
    redirects.push({
      from,
      to,
      permanent,
      created: new Date().toISOString(),
    });
  }

  saveRedirects(configPath, redirects);
  return redirects;
}

/**
 * Generate Next.js redirects config
 */
function generateNextJSRedirects(configPath) {
  const redirects = loadRedirects(configPath);

  let code = '// Auto-generated by seo-infrastructure.js\n';
  code += '// Do not edit manually - use the redirect management system\n\n';
  code += 'module.exports = [\n';

  redirects.forEach((redirect) => {
    code += '  {\n';
    code += `    source: '${redirect.from}',\n`;
    code += `    destination: '${redirect.to}',\n`;
    code += `    permanent: ${redirect.permanent},\n`;
    code += '  },\n';
  });

  code += '];\n';

  return code;
}

/**
 * Generate performance optimization hints
 */
function generatePerformanceHints() {
  return {
    lazyLoadingImages: {
      html: '<img loading="lazy" src="..." alt="..." />',
      nextjs: '<Image loading="lazy" src="..." alt="..." />',
      note: 'Add loading="lazy" to all images below the fold',
    },
    preconnectHints: {
      google_fonts: '<link rel="preconnect" href="https://fonts.googleapis.com" />',
      google_analytics: '<link rel="dns-prefetch" href="https://www.google-analytics.com" />',
      cdn: '<link rel="preconnect" href="https://cdn.example.com" crossorigin />',
      note: 'Add these to <head> for faster third-party resource loading',
    },
    criticalCSS: {
      note: 'Extract above-the-fold CSS and inline it in <head>',
      tools: ['critical', 'penthouse', 'critters-webpack-plugin'],
      example: '<style>/* Critical CSS here */</style>',
    },
    fontOptimization: {
      note: 'Use font-display: swap to prevent invisible text',
      css: "@font-face { font-display: swap; }",
    },
    imageOptimization: {
      formats: ['WebP', 'AVIF'],
      note: 'Use modern image formats with fallbacks',
      example: '<picture><source srcset="image.avif" type="image/avif"><source srcset="image.webp" type="image/webp"><img src="image.jpg" alt="..."></picture>',
    },
  };
}

module.exports = {
  parseFrontmatter,
  extractH1,
  extractImages,
  generateSitemap,
  generateRobotsTxt,
  generateCanonical,
  generateOpenGraph,
  generateTwitterCard,
  generateJSONLD,
  suggestAltText,
  loadRedirects,
  saveRedirects,
  addRedirect,
  generateNextJSRedirects,
  generatePerformanceHints,
};
